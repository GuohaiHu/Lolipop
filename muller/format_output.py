from typing import Any, Dict, Tuple, List, Union, Optional
import pandas
from pathlib import Path
import subprocess
from dataclasses import dataclass
import random

OutputType = Tuple[pandas.DataFrame, pandas.DataFrame, str, Dict[str, Any]]
try:
	import yaml
except ModuleNotFoundError:
	yaml = None

try:
	from muller.get_genotypes import GenotypeOptions
	from muller.sort_genotypes import SortOptions
	from muller.order_clusters import OrderClusterParameters, ClusterType
	from muller.genotype_plots import plot_genotypes
except ModuleNotFoundError:
	# noinspection PyUnresolvedReferences
	from get_genotypes import GenotypeOptions
	# noinspection PyUnresolvedReferences
	from sort_genotypes import SortOptions
	# noinspection PyUnresolvedReferences
	from order_clusters import OrderClusterParameters, ClusterType
	# noinspection PyUnresolvedReferences
	from genotype_plots import plot_genotypes


@dataclass
class WorkflowData:
	filename: Path
	info: Optional[pandas.DataFrame]
	original_trajectories: Optional[pandas.DataFrame]
	original_genotypes: Optional[pandas.DataFrame]
	trajectories: pandas.DataFrame
	genotypes: pandas.DataFrame
	clusters: ClusterType
	genotype_options: GenotypeOptions
	sort_options: SortOptions
	cluster_options: OrderClusterParameters


def convert_population_to_ggmuller_format(mean_genotypes: pandas.DataFrame, backgrounds:pandas.DataFrame, fixed_cutoff:float) -> pandas.DataFrame:
	"""
		Converts the genotype frequencies to a population table suitable for ggmuller.
	Parameters
	----------
	mean_genotypes: pandas.DataFrame
	backgrounds: pandas.DataFrame
		The output from create_ggmuller_edges()
	fixed_cutoff: float
		The cutoff used to identify if/when a genotype fixes.

	Returns
	-------

	"""
	table = list()



	# "Generation", "Identity" and "Population"
	# Adjust populations to account for inheritance.
	# If a child genotype fixed, the parent genotype should be replaced.
	modified_genotypes: pandas.DataFrame = mean_genotypes.copy()
	modified_genotypes.pop('members')

	fixed_genotypes = backgrounds.groupby(by = 'Parent')
	numeric_columns = get_numeric_columns(mean_genotypes.columns)
	for genotype_label, row in modified_genotypes.iterrows():

		if genotype_label in backgrounds['Parent'].values:
			# Find the first timepoint a child genotype fixed.

			background = fixed_genotypes.get_group(genotype_label)

			children = modified_genotypes.loc[list(background['Identity'].values)]
			transposed = children.transpose()

			first_fixed: pandas.Series = (transposed > fixed_cutoff).idxmax(0).sort_values()
			# noinspection PyTypeChecker
			first_fixed = first_fixed[first_fixed > 0]
			if first_fixed.empty:
				genotype_timepoint_cutoff = max(modified_genotypes.columns)
			else:
				#fixed_children = background[background > fixed_cutoff]

				# Get the child that fixed first.
				successor = first_fixed.idxmin(0)

				genotype_timepoint_cutoff = first_fixed[successor]
		else:
			genotype_timepoint_cutoff = max(modified_genotypes.columns)
		for column, value in row.items():
			# if isinstance(column, str): continue
			if column not in numeric_columns: continue
			if column > genotype_timepoint_cutoff:
				continue
			line = {
				'Generation': column,
				'Identity':   int(row.name.split('-')[-1]),
				'Population': value * 100
			}
			table.append(line)
	df = pandas.DataFrame(table)
	generations = df.groupby(by = 'Generation')

	root_genotype_generations = list()
	for generation, gdf in generations:
		total = gdf['Population'].sum()
		value = 100.0 - total
		if value < 0:
			value = 0
		row = {
			'Generation': generation,
			'Identity':   0,
			'Population': value
		}
		root_genotype_generations.append(row)

	fdf = pandas.concat([df, pandas.DataFrame(root_genotype_generations)])
	fdf['Identity'] = ["genotype-{}".format(i) for i in fdf['Identity'].values]
	return fdf.sort_values(by = 'Generation')


def create_ggmuller_edges(genotype_clusters: ClusterType) -> pandas.DataFrame:
	table = list()
	for genotype_label, genotype_info in genotype_clusters.items():
		background = genotype_info.background

		if len(background) == 1:
			parent = 'genotype-0'
			identity = background[0]
		else:
			parent, identity = background[-2:]

		row = {
			'Parent':   parent,
			'Identity': identity
		}
		table.append(row)
	return pandas.DataFrame(table)[['Parent', 'Identity']]



def generate_formatted_output(workflow_data: WorkflowData, color_palette: Dict[str, str], fixed_cutoff:float) -> OutputType:
	"""
		Generates the final output files for the population.
	Parameters
	----------
	workflow_data: WorkflowData
		The data generated by the workflow.
	color_palette: Dict[str, str]
		A map dictating the color of each genotype.
	fixed_cutoff: float
		The cutoff to indicate if/when a genotype has fixed.

	Returns
	-------
	Tuple[pandas.DataFrame, Dict[str,Any], pandas.DataFrame, Dict[str,float], str, pandas.DataFrame, pandas.DataFrame]
	"""

	workflow_parameters = get_workflow_parameters(workflow_data)

	ggmuller_edge_table = create_ggmuller_edges(workflow_data.clusters)
	ggmuller_population_table = convert_population_to_ggmuller_format(workflow_data.genotypes, ggmuller_edge_table, fixed_cutoff)
	mermaid_diagram = generate_mermaid_diagram(ggmuller_edge_table, color_palette)
	if workflow_data.info is not None:
		genotype_map = {k: v.split('|') for k, v in workflow_data.genotypes['members'].items()}
		trajectory_map = dict()
		for g, v in genotype_map.items():
			for t in v:
				trajectory_map[t] = g
		trajectory_table: pandas.DataFrame = workflow_data.trajectories.copy()

		trajectory_table['genotype'] = [trajectory_map[k] for k in trajectory_table.index]
		trajectory_table = trajectory_table.join(workflow_data.info).sort_values(by = ['genotype'])
		workflow_data.trajectories = trajectory_table

	return ggmuller_population_table, ggmuller_edge_table, mermaid_diagram, workflow_parameters


def generate_mermaid_diagram(backgrounds: pandas.DataFrame, color_palette: Dict[str, str]) -> str:
	"""
	graph LR
    id1(Start)-->id2(Stop)
    style id1 fill:#f9f,stroke:#333,stroke-width:4px
    style id2 fill:#ccf,stroke:#f66,stroke-width:2px,stroke-dasharray: 5, 5
	Parameters
	----------
	backgrounds
	color_palette

	Returns
	-------

	"""
	genotype_labels = list(set(backgrounds['Identity'].values))

	node_map = {k: "style id{} fill:{}".format(k.split('-')[-1], color_palette[k]) for k in genotype_labels}

	diagram_contents = ["graph TD;"]
	for index, row in backgrounds.iterrows():
		parent = row['Parent']
		identity = row['Identity']
		parent_id = parent.split('-')[-1]
		identity_id = identity.split('-')[-1]
		line = "id{left_id}(genotype-{left})-->id{right_id}(genotype-{right});".format(
			left_id = identity_id,
			right_id = parent_id,
			left = identity,
			right = parent
		)
		diagram_contents.append(line)

	diagram_contents += list(node_map.values())

	return "\n".join(diagram_contents)


def generate_output(workflow_data: WorkflowData, output_folder:Path, fixed_cutoff:float):
	color_palette = [
		'#e6194b', '#3cb44b', '#ffe119', '#4363d8', '#f58231',
		'#911eb4', '#46f0f0', '#f032e6', '#bcf60c', '#fabebe',
		'#008080', '#e6beff', '#9a6324', '#fffac8', '#800000',
		'#aaffc3', '#808000', '#ffd8b1', '#000075', '#808080',
		'#ffffff', '#000000'
	]

	if len(workflow_data.original_genotypes) >= len(color_palette):
		color_palette += [generate_random_color() for _ in workflow_data.genotypes.index]

	color_map = {i: j for i, j in zip(sorted(workflow_data.genotypes.index), color_palette)}

	population, edges, mermaid, parameters = generate_formatted_output(workflow_data, color_map, fixed_cutoff)
	save_output(workflow_data, population, edges, mermaid, parameters, output_folder, color_map)


def generate_r_script(population: Path, edges: Path, output_file: Path, color_palette: Dict[str, str]) -> str:
	script = """
	library(ggplot2)
	library(ggmuller)
	
	population <- read.table("{population}", header=TRUE)
	edges <- read.table("{edges}", header=TRUE)
	
	Muller_df <- get_Muller_df(edges, population)
	#Muller_plot(Muller_df, add_legend = TRUE)
	
	palette <- c({palette})
	ggplot(Muller_df, aes_string(x = "Generation", y = "Frequency", group = "Group_id", fill = "Identity", colour = "Identity")) + 
    geom_area() +
    theme(legend.position = "right") +
    guides(linetype = FALSE, color = FALSE) + 
    scale_y_continuous(labels = 25 * (0:4), name = "Percentage", expand=c(0,0)) +
    scale_x_continuous(expand=c(0,0)) + 
    scale_fill_manual(name = "Identity", values = palette) +
    scale_color_manual(values = palette)
	ggsave("{output}", height = 10, width = 10)
	""".format(
		population = population.absolute(),
		edges = edges.absolute(),
		output = output_file.absolute(),
		palette = ",".join(['"#333333"'] + ['"{}"'.format(v) for k, v in sorted(color_palette.items())])
	)
	script = '\n'.join(i.strip() for i in script.split('\n'))

	return script


def generate_random_color() -> str:
	r = random.randint(100, 255)
	g = random.randint(100, 255)
	b = random.randint(100, 255)
	color = "#{:>02X}{:>02X}{:>02X}".format(r, g, b)
	return color


def get_numeric_columns(columns: List) -> List[Union[int, float]]:
	output_columns = list()
	for col in columns:
		try:
			int(col)
			output_columns.append(col)
		except ValueError:
			pass
	return output_columns


def get_workflow_parameters(workflow_data: WorkflowData) -> Dict[str, float]:
	parameters = {
		# get_genotype_options
		'detectionCutoff':                        workflow_data.genotype_options.detection_breakpoint,
		'fixedCutoff':                            workflow_data.genotype_options.fixed_breakpoint,
		'similarityCutoff':                       workflow_data.genotype_options.similarity_breakpoint,
		'differenceCutoff':                       workflow_data.genotype_options.difference_breakpoint,
		# sort options
		'significanceCutoff':                     workflow_data.sort_options.significant_breakpoint,
		'frequencyCutoffs':                       workflow_data.sort_options.frequency_breakpoints,
		# cluster options
		'additiveBackgroundDoubleCheckCutoff':    workflow_data.cluster_options.additive_background_double_cutoff,
		'additiveBackgroundSingleCheckCutoff':    workflow_data.cluster_options.additive_background_single_cutoff,
		'subtractiveBackgroundDoubleCheckCutoff': workflow_data.cluster_options.subtractive_background_double_cutoff,
		'subtractiveBackgroundSingleCheckCutoff': workflow_data.cluster_options.subtractive_background_single_cutoff,
		'derivativeDetectionCutoff':              workflow_data.cluster_options.derivative_detection_cutoff,
		'derivativeCheckCutoff':                  workflow_data.cluster_options.derivative_check_cutoff
	}
	return parameters


def save_output(workflow_data: WorkflowData, population_table: pandas.DataFrame, edge_table: pandas.DataFrame,
		mermaid_diagram: str, parameters: Dict, output_folder: Path, color_palette: Dict[str, str]):
	name = workflow_data.filename.stem
	delimiter = '\t'
	subfolder = output_folder / "supplementary_files"
	if not subfolder.exists():
		subfolder.mkdir()

	original_trajectory_file = subfolder / (name + '.trajectories.original.tsv')
	trajectory_output_file = output_folder / (name + '.trajectories.tsv')

	original_genotype_file = subfolder / (name + '.genotypes.original.tsv')
	genotype_output_file = output_folder / (name + '.genotypes.tsv')

	population_output_file = output_folder / (name + '.ggmuller.populations.tsv')
	edges_output_file = output_folder / (name + '.ggmuller.edges.tsv')

	r_script_file = subfolder / (name + '.r')
	r_script_graph_file = output_folder / (name + '.muller.png')

	mermaid_diagram_script = subfolder / (name + '.mermaid.md')
	mermaid_diagram_render = output_folder / (name + '.mermaid.png')

	original_genotype_plot_filename = subfolder / (name + '.original.png')
	genotype_plot_filename = output_folder / (name + '.filtered.png')

	population_table.to_csv(str(population_output_file), sep = delimiter, index = False)
	edge_table.to_csv(str(edges_output_file), sep = delimiter, index = False)

	workflow_data.original_genotypes.to_csv(str(original_genotype_file), sep = delimiter)
	workflow_data.genotypes.to_csv(str(genotype_output_file), sep = delimiter)

	if workflow_data.original_trajectories is not None:
		workflow_data.original_trajectories.to_csv(str(original_trajectory_file), sep = delimiter)

	if workflow_data.trajectories is not None:
		workflow_data.trajectories.to_csv(str(trajectory_output_file), sep = delimiter)

	plot_genotypes(workflow_data.original_trajectories, workflow_data.original_genotypes, original_genotype_plot_filename, color_palette)
	plot_genotypes(workflow_data.trajectories, workflow_data.genotypes, genotype_plot_filename, color_palette)

	mermaid_diagram_script.write_text(mermaid_diagram)
	try:
		subprocess.call(
			["mmdc", "--height", "400", "-i", mermaid_diagram_script, "-o", mermaid_diagram_render],
			stdout = subprocess.PIPE,
			stderr = subprocess.PIPE)
	except FileNotFoundError:
		pass

	r_script = generate_r_script(
		population = population_output_file,
		edges = edges_output_file,
		output_file = r_script_graph_file,
		color_palette = color_palette
	)
	r_script_file.write_text(r_script)

	subprocess.call(['Rscript', '--vanilla', '--silent', r_script_file], stdout = subprocess.PIPE,
		stderr = subprocess.PIPE)
	_extra_file = Path.cwd() / "Rplots.pdf"
	if _extra_file.exists():
		_extra_file.unlink()

	if yaml:
		fname = output_folder / (name + '.yaml')
		fname.write_text(yaml.dump(parameters))
	else:
		import json
		fname = output_folder / (name + '.json')
		fname.write_text(json.dumps(parameters, indent = 2))
