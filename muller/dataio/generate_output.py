import json
from dataclasses import dataclass
from pathlib import Path
from typing import Any, Dict, Optional, Tuple

import pandas
from loguru import logger

from muller.clustering.metrics.pairwise_calculation_cache import PairwiseCalculationCache
from muller.graphics import plot_genotypes, plot_heatmap, plot_dendrogram, AnnotatedMullerDiagram, plot_timeseries, flowchart
from muller.dataio.generate_tables import *
from muller.dataio.generate_scripts import generate_r_script
from muller import widgets, dataio, palettes

ROOT_GENOTYPE_LABEL = "genotype-0"
FILTERED_GENOTYPE_LABEL = "removed"

@dataclass
class WorkflowData:
	# Used to organize the output from the workflow.
	version: str
	filename: Path
	program_options: Any
	info: Optional[pandas.DataFrame]
	original_trajectories: Optional[pandas.DataFrame]
	original_genotypes: Optional[pandas.DataFrame]
	rejected_trajectories: pandas.DataFrame
	trajectories: pandas.DataFrame
	genotypes: pandas.DataFrame
	genotype_members: pandas.Series
	clusters: Any
	p_values: PairwiseCalculationCache
	filter_cache: List[Tuple[pandas.DataFrame, pandas.DataFrame]]
	linkage_matrix: Any
	genotype_palette_filename: Optional[Path]


class OutputFilenames:
	""" Used to organize the files generated by the workflow.
	"""

	def __init__(self, output_folder: Path, name: str, suffix = 'tsv'):
		self.suffix = suffix

		def check_folder(path: Union[str, Path]) -> Path:
			path = Path(path)
			if not path.exists():
				path.mkdir()
			return path.absolute()

		output_folder = check_folder(output_folder)
		supplementary_folder = check_folder(output_folder / "supplementary-files")
		graphics_folder = check_folder(output_folder / "graphics")
		graphics_distinctive_folder = check_folder(graphics_folder / "distinctive")
		graphics_clade_folder = check_folder(graphics_folder / "clade")
		tables_folder = check_folder(output_folder / "tables")
		scripts_folder = check_folder(output_folder / "scripts")

		# General Files
		self.trajectory_table: Path = output_folder / (name + f'.trajectories.{suffix}')
		self.genotype_table: Path = output_folder / (name + f'.muller_genotypes.{suffix}')
		#self.muller_plot_annotated: Path = output_folder / (name + '.muller.annotated.png')
		#self.muller_plot_unannotated_general: Path = output_folder / (name + '.muller.unannotated.png')

		# tables
		self.original_trajectory: Path = tables_folder / (name + f'.trajectories.original.{suffix}')
		self.original_genotype: Path = tables_folder / (name + f'.muller_genotypes.original.{suffix}')
		self.rejected_trajectories: Path = tables_folder / (name + f"trajectories.rejected.{suffix}")
		self.ggmuller_population: Path = tables_folder / (name + f'.ggmuller.populations.{suffix}')
		self.ggmuller_edges: Path = tables_folder / (name + f'.ggmuller.edges.{suffix}')
		self.muller_table: Path = tables_folder / (name + f'.muller.csv')  # This is generated in r.

		self.linkage_matrix_table = tables_folder / (name + f".linkagematrix.tsv")
		self.distance_table: Path = tables_folder / (name + ".distance.tsv")
		self.distance_matrix: Path = tables_folder / (name + f".distance.{suffix}")

		# graphics
		# Muller Plots
		# The muller diagram generator will automatically add filetype extensions and an svg render of each file.
		self.muller_diagram_clade_annotated: Path = graphics_clade_folder / (name + '.clade.annotated')
		self.muller_diagram_clade_unannotated: Path = graphics_clade_folder / (name + '.clade.unannotated')
		self.muller_diagram_distinct_annotated:Path = graphics_distinctive_folder / (name + '.distinct.annotated')
		self.muller_diagram_distinct_unannotated:Path = graphics_distinctive_folder / (name + '.distinct.unannotated')

		#self.muller_plot_basic: Path = graphics_clade_folder / (name + '.muller.basic.png')
		#self.muller_plot_annotated_distinctive: Path = graphics_distinctive_folder / (name + '.muller.annotated.distinctive.png')

		##Timeseries plots
		self.genotype_plot: Path = graphics_distinctive_folder / (name + '.genotypes.distinctive.png')
		self.trajectory_plot_distinctive: Path = graphics_distinctive_folder / (name + f".trajectories.distinctive.svg")
		self.genotype_plot_filtered: Path = output_folder / (name + f".genotypes.filtered.png")

		## Geneology plots
		self.lineage_image_clade: Path = graphics_distinctive_folder / (name + f".lineage.clade.png")
		self.lineage_image_clade_render: Path = output_folder / (name + '.lineage.clade.svg')
		self.lineage_image_distinct: Path = output_folder / (name + '.lineage.distinct.png')
		self.lineage_image_distinct_render: Path = output_folder / (name + '.lineage.distinct.svg')

		## Other plots
		self.distance_heatmap: Path = graphics_folder / (name + f".heatmap.distance.png")
		self.linkage_plot = graphics_folder / (name + f".dendrogram.png")

		# scripts
		self.r_script: Path = scripts_folder / (name + '.r')
		self.mermaid_script: Path = scripts_folder / (name + '.mermaid.md')

		# supplementary files
		self.parameters: Path = supplementary_folder / (name + '.options.json')
		self.genotype_scores: Path = supplementary_folder / (name + '.nestscores.tsv')

	@property
	def delimiter(self) -> str:
		if self.suffix == 'tsv':
			return '\t'
		else:
			return ','


class MullerOutputGenerator:
	""" Organizes the workflow for generating the output from the muller workflow."""

	def __init__(self, workflow_data: WorkflowData, output_folder: Path, adjust_populations: bool, render: bool = True):
		self.workflow_data = workflow_data
		self.output_folder = output_folder
		self.adjust_populations = adjust_populations
		self.render = render  # Whether to include svg versions of each graph.

		self.muller_generator = AnnotatedMullerDiagram(
			outlines = self.workflow_data.program_options['draw_outline'],
			render = self.workflow_data.program_options['render']
		)


		if self.workflow_data.program_options['name']:
			base_filename = self.workflow_data.program_options['name']
		else:
			base_filename = self.workflow_data.filename.stem
		if self.workflow_data.program_options['sheetname'] and self.workflow_data.program_options['sheetname'] != 'Sheet1':
			base_filename += '.' + self.workflow_data.program_options['sheetname']

		self.filenames = OutputFilenames(output_folder, base_filename)

	def run(self):
		parent_genotypes = widgets.map_trajectories_to_genotype(self.workflow_data.genotype_members)
		genotype_annotations = self.read_genotype_annotations()

		filtered_trajectories = self.save_base_tables(parent_genotypes)
		edges_table, population_table = self.save_ggmuller_files()

		genotype_colors_clade, genotype_colors_distinct = self.generate_palettes(edges_table, genotype_annotations)

		self.save_workflow_parameters(genotype_colors_clade, genotype_colors_distinct)
		self.generate_genotype_plots(genotype_colors_clade, genotype_colors_distinct, parent_genotypes, filtered_trajectories)

		muller_df = self.save_r_script(genotype_colors_clade, population_table)

		if muller_df is not None:
			self.save_muller_plots(muller_df, genotype_colors_clade, genotype_colors_distinct, genotype_annotations)

		if self.workflow_data.linkage_matrix is not None:
			self.save_linkage_files()

		if self.workflow_data.trajectories is not None:
			self.save_trajectory_distance_information()

	def save_workflow_parameters(self, clade_palette, distinct_palette):
		parameters = {k: (v if not isinstance(v, Path) else str(v)) for k, v in self.workflow_data.program_options.items()}
		parameters['genotypeColorsClade'] = clade_palette
		parameters['genotypeColorsDistinct'] = distinct_palette
		parameters['version'] = self.workflow_data.version
		self.filenames.parameters.write_text(json.dumps(parameters, indent = 2))

	def save_r_script(self, palette: Dict[str, str], population_table: pandas.DataFrame) -> pandas.DataFrame:
		# Generate the rscript and ggmuller DataFrame
		# TODO replicate how the r script generates the muller_df file so that we don't have to run the rscript.
		muller_df = generate_r_script(
			trajectory = self.filenames.trajectory_table,
			population = self.filenames.ggmuller_population,
			edges = self.filenames.ggmuller_edges,
			table_filename = self.filenames.muller_table,
			plot_filename = self.filenames.muller_plot_basic,
			script_filename = self.filenames.r_script,
			color_palette = palette,
			genotype_labels = population_table['Identity'].unique().tolist()
		)
		return muller_df

	def save_base_tables(self, parent_genotypes) -> Optional[pandas.DataFrame]:
		""" Save the genotype and trajectory tables to the output folder."""
		logger.info("Saving Trajectory and Genotype Tables...")
		self.workflow_data.genotypes.to_csv(str(self.filenames.genotype_table), sep = self.filenames.delimiter)

		# Save trajectory tables, if available
		if self.workflow_data.trajectories is not None:
			filtered_trajectories = generate_missing_trajectories_table(self.workflow_data.trajectories, self.workflow_data.original_trajectories)
			trajectories = generate_trajectory_table(self.workflow_data.trajectories, parent_genotypes, self.workflow_data.info)
			trajectories.to_csv(str(self.filenames.trajectory_table), sep = self.filenames.delimiter)
		else:
			filtered_trajectories = None

		if self.workflow_data.rejected_trajectories is not None:
			self.workflow_data.rejected_trajectories.to_csv(self.filenames.rejected_trajectories, sep = self.filenames.delimiter)

		return filtered_trajectories

	def save_ggmuller_files(self) -> Tuple[pandas.DataFrame, pandas.DataFrame]:
		edges_table = self.workflow_data.clusters.as_ancestry_table().reset_index()
		edges_table = edges_table[['Parent', 'Identity']]  # Otherwise the r script doesn't work.

		population_table = generate_ggmuller_population_table(
			self.workflow_data.genotypes,
			edges_table,
			self.workflow_data.program_options['detection_breakpoint'],
			self.adjust_populations
		)

		population_table.to_csv(str(self.filenames.ggmuller_population), sep = self.filenames.delimiter, index = False)
		edges_table.to_csv(str(self.filenames.ggmuller_edges), sep = self.filenames.delimiter, index = False)
		return edges_table, population_table

	def read_genotype_annotations(self) -> Dict[str, List[str]]:
		if self.workflow_data.info is not None:
			genotype_annotations = dataio.parse_genotype_annotations(
				self.workflow_data.genotype_members,
				self.workflow_data.info,
				self.workflow_data.program_options['alias_filename']
			)
		else:
			genotype_annotations = {}
		return genotype_annotations

	def generate_palettes(self, edges_table: pandas.DataFrame, genotype_annotations: Dict[str, List[str]]) -> Tuple[Dict[str, str], Dict[str, str]]:
		_all_genotype_labels = sorted(set(list(self.workflow_data.original_genotypes.index) + list(self.workflow_data.genotypes.index)))
		# Annotations may be used to select specific colors for the lineage palette.

		# The custom palette overrides any other color.
		if self.workflow_data.genotype_palette_filename:
			custom_palette = dataio.read_map(self.workflow_data.genotype_palette_filename)
		else:
			custom_palette = {}

		genotype_colors_distinct = palettes.generate_palette(_all_genotype_labels)
		genotype_colors_clade = palettes.generate_palette(edges_table, custom_palette, genotype_annotations, 'lineage')

		return genotype_colors_clade, genotype_colors_distinct

	def save_lineage_plots(self, genotype_annotations: [Dict[str, str]], clade_palette: Dict[str, str], distinct_palette: Dict[str, str]):
		logger.info("Generating Lineage Plots...")
		edges_table = self.workflow_data.clusters.priority_table()
		flowchart.flowchart(edges_table, clade_palette, annotations = genotype_annotations, filename = self.filenames.lineage_image_distinct)
		flowchart.flowchart(edges_table, distinct_palette, annotations = genotype_annotations, filename = self.filenames.lineage_image_clade)
		if self.render:
			flowchart.flowchart(edges_table, clade_palette, annotations = genotype_annotations,
				filename = self.filenames.lineage_image_distinct_render)
			flowchart.flowchart(edges_table, distinct_palette, annotations = genotype_annotations,
				filename = self.filenames.lineage_image_clade_render)

	def generate_genotype_plots(self, clade_palette, distinct_palette, parent_genotypes, filtered_trajectories):
		# TODO make sure both distinctive and clade versions are made.
		logger.info("Generating series plots...")
		trajectory_colors_distinct = {k: distinct_palette[v] for k, v in parent_genotypes.items()}
		trajectory_colors_lineage = {k: clade_palette[v] for k, v in parent_genotypes.items()}

		plot_genotypes(
			self.workflow_data.trajectories,
			self.workflow_data.genotypes,
			self.filenames.genotype_plot,
			distinct_palette,
			trajectory_colors_distinct
		)

		if self.workflow_data.trajectories is not None:
			plot_timeseries(self.workflow_data.trajectories, trajectory_colors_distinct, filename = self.filenames.trajectory_plot_distinctive)
			plot_genotypes(filtered_trajectories, self.workflow_data.genotypes, self.filenames.genotype_plot_filtered, clade_palette,
				trajectory_colors_lineage)

	def save_muller_plots(self, muller_df: pandas.DataFrame, clade_palette, distinct_palette, genotype_annotations):
		##############################################################################################################################################
		# ------------------------------------- Generate the muller plot using the table from the r script -------------------------------------------
		##############################################################################################################################################
		logger.info("Generating muller plots...")

		# Draw the muller diagrams
		# Start with the annotated and unannotated clade palettes.
		self.muller_generator.run(muller_df, clade_palette, self.filenames.muller_diagram_clade_annotated, genotype_annotations)
		self.muller_generator.run(muller_df, clade_palette, self.filenames.muller_diagram_clade_unannotated)

		# Draw the distinctive muller diagrams
		self.muller_generator.run(muller_df, distinct_palette, self.filenames.muller_diagram_clade_annotated, genotype_annotations)
		self.muller_generator.run(muller_df, distinct_palette, self.filenames.muller_diagram_clade_unannotated)


	def save_linkage_files(self):
		num_trajectories = len(self.workflow_data.trajectories)
		linkage_table = widgets.format_linkage_matrix(self.workflow_data.linkage_matrix, num_trajectories)

		linkage_table.to_csv(str(self.filenames.linkage_matrix_table), sep = self.filenames.delimiter, index = False)


		plot_dendrogram(self.workflow_data.linkage_matrix, self.workflow_data.p_values, self.filenames.linkage_plot)

	def save_trajectory_distance_information(self):
		self.workflow_data.p_values.save(self.filenames.distance_table)


		squareform = self.workflow_data.p_values.squareform()
		squareform.to_csv(self.filenames.distance_matrix)


		pvalues_matrix = self.workflow_data.p_values.squareform()

		plot_heatmap(pvalues_matrix, self.filenames.distance_heatmap)


	def save_supplementary_files(self):
		##############################################################################################################################################
		# ---------------------------------------------------- Generate supplementary files ----------------------------------------------------------
		##############################################################################################################################################

		self.workflow_data.clusters.to_table().to_csv(self.filenames.genotype_scores, sep = '\t')


